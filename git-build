#!/bin/bash -e

showhelp () {
    echo "Usage:"
    echo "  git build [--tag=<tag>] [--base=<branch>] [<branch> ...]"
    echo "  git build --version"
    echo "  git build --help"
}

showver () {
    local script="$0"
    local dir=$(dirname "$script")
    local pkg="$dir/package.json"
    local verline=$(grep '"version"' < $pkg | head -n1)
    local ver=$(sed -e 's/.*": "//' -e 's/".*//' <<< "$verline")
    echo $ver
}

declare tag=qa
declare base=master
declare restore
declare branch
declare spec
declare -a branches

while test $# -gt 0; do
    case "$1" in
        --help)     showhelp;       exit;;
        --tag)      tag=$2;         shift 2;;
        --base)     base=$2;        shift 2;;
        --tag=*)    tag=${1#*=};    shift;;
        --base=*)   base=${1#*=};   shift;;
        --version)  showver;        exit;;
        --)                         shift; break;;
        *)                          break;;
    esac
done

if ! test "$tag"; then
    echo "Tag cannot be empty" >&2
    exit 3
elif ! test "$base"; then
    echo "Branch cannot be empty" >&2
    exit 4
elif ! git rev-parse HEAD &>/dev/null; then
    echo "Cannot find HEAD" >&2
    exit 10
elif test $(git status --porcelain 2>/dev/null | wc -l) -gt 0; then
    echo "Working tree is not clean" >&2
    exit 11
fi

restore=$(git rev-parse --abbrev-ref HEAD)

echo fetching latest from origin
git fetch >/dev/null

echo detaching from origin/$base
git checkout --detach "origin/$base" 2>/dev/null

IFS=$'\n' branches=($(sort <<< "$*"))
unset IFS

for branch in ${branches[@]}; do
    echo merging $branch
    git merge --no-ff -m"codeploy merging $branch" "origin/$branch" >/dev/null
done

echo creating $tag tag
spec="$base+[${branches[@]}]"
git tag -fa -m"creating $tag build from $spec" $tag >/dev/null

echo pushing $tag tag to origin
git push -qf origin $tag >/dev/null

echo restoring $restore branch
git checkout -q $restore >/dev/null

echo pushed $tag build tag
